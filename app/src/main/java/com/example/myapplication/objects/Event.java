package com.example.myapplication.objects;

import android.os.Build;
import android.os.Parcel;
import android.os.Parcelable;
import android.util.Log;

import com.google.firebase.firestore.FirebaseFirestore;
import com.google.firebase.firestore.PropertyName;
import com.google.firebase.firestore.auth.User;

import java.io.Serializable;
import java.util.ArrayList;
import java.util.List;
import java.util.Random;


/**
 * The Event class represents an event with various attributes like ID, title, description, poster URL, date, and limit on entrants.
 */
public class Event implements Serializable, Parcelable {
    private String id; // Unique identifier for the event, typically generated by Firestore.
    private String creatorID; // Device ID of the user who created the event
    private Boolean firstDraw = true;

    @PropertyName("name")
    private String title; // Title or name of the event.

    private String description; // Description of the event, providing more details.
    private String posterUrl; // URL pointing to the event's poster image stored in Firebase Storage.

    @PropertyName("qrCodeUrl")
    private String QRcode;

    @PropertyName("dateTime")
    private String dateTime; // Date and time of the event.

    private Long limitEntrants; // Maximum number of entrants allowed for the event; stored as a Long to handle larger numbers.
    private Long maxCapacity;

    @PropertyName("geolocationEnabled")
    private boolean geolocationEnabled;

    @PropertyName("waitlist")
    private WaitingList waitingList = new WaitingList(new ArrayList<String>());

    private ArrayList<String> cancelledList = new ArrayList<String>();
    private ArrayList<String> confirmedList = new ArrayList<String>();
    private ArrayList<String> lottery = new ArrayList<String>();

    ///
    // private Lottery lottery = new Lottery(new ArrayList<String>());


    ////

    /**
     * Default constructor required by Firestore to create instances of the Event class.
     */
    public Event() {
        // No initialization required, used by Firestore during data retrieval.
    }


    /**
     * Constructor to create an Event instance with specific attributes.
     */
    public Event(String id, String title, String description, String posterUrl, Long limitEntrants) {
        this.id = id; // Assign the unique ID to the event instance.
        this.title = title; // Set the event title.
        this.description = description; // Set the event description.
        this.posterUrl = posterUrl; // Set the URL for the event's poster image.
        this.limitEntrants = limitEntrants; // Set the maximum number of entrants allowed.
        this.waitingList = new WaitingList(new ArrayList<String>());

    }


    /**
     * Constructor for the administrator's use.
     * @param eventID
     * @param title
     * @param description
     * @param posterUrl
     * @param QRcode
     * @param creatorID
     */
    public Event(String eventID, String title, String description, String posterUrl, String QRcode, String creatorID) {
        this.id = eventID;
        this.title = title; // Set the event title.
        this.description = description; // Set the event description.
        this.posterUrl = posterUrl; // Set the URL for the event's poster image.
        this.QRcode = QRcode;
        this.creatorID = creatorID;

    }


    /**
     * implementing parcelable interface
     * @param in the parcel from which to read the data
     */
    protected Event(Parcel in) {
        id = in.readString();
        title = in.readString();
        description = in.readString();
        posterUrl = in.readString();
        QRcode = in.readString();
        creatorID = in.readString();

        // Handle nullable maxCapacity
        if (in.readByte() == 0) {
            maxCapacity = null;
        } else {
            maxCapacity = in.readLong();
        }

        // Read lists
        lottery = in.createStringArrayList();
        cancelledList = in.createStringArrayList();
        confirmedList = in.createStringArrayList();

        // Read waitingList
        ArrayList<String> waitlistData = in.createStringArrayList();
        waitingList = new WaitingList(waitlistData);

        // Handle nullable firstDraw
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.Q) {
            firstDraw = in.readBoolean();
        } else {
            firstDraw = in.readByte() != 0;
        }
    }



    /**
     * writing the object to a parcel
     * @param dest destination parcel
     * @param flags flags
     */
    @Override
    public void writeToParcel(Parcel dest, int flags) {
        dest.writeString(id);
        dest.writeString(title);
        dest.writeString(description);
        dest.writeString(posterUrl);
        dest.writeString(QRcode);
        dest.writeString(creatorID);

        // Write nullable maxCapacity
        if (maxCapacity == null) {
            dest.writeByte((byte) 0);
        } else {
            dest.writeByte((byte) 1);
            dest.writeLong(maxCapacity);
        }

        // Write lists
        dest.writeStringList(lottery);
        dest.writeStringList(cancelledList);
        dest.writeStringList(confirmedList);

        // Write waitingList
        dest.writeStringList(waitingList.getList());

        // Write nullable firstDraw
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.Q) {
            dest.writeBoolean(firstDraw != null && firstDraw);
        } else {
            dest.writeByte((byte) (firstDraw != null && firstDraw ? 1 : 0));
        }
    }



    /**
     * describe contents is required for implementing parcelable
     * @return 0
     */
    @Override
    public int describeContents() {
        return 0;
    }


    /**
     * methods to create an event class from a parcel
     */
    public static final Creator<Event> CREATOR = new Creator<Event>() {
        @Override
        public Event createFromParcel(Parcel in) {
            return new Event(in);
        }

        @Override
        public Event[] newArray(int size) {
            return new Event[size];
        }
    };

    /**
     * Getter method to get the id of the creator
     * @return
     *      Id of the creator
     */
    public String getCreatorID() {
        return creatorID;
    }

    public void setCreatorID(String creatorID) {
        this.creatorID = creatorID;
    }

    /**
     *  Getter method to retrieve the event ID.
     * @return
     *      id of the event
     */
    public String getId() {
        return id; // Return the unique identifier of the event.
    }


    /**
     * Setter method to set the event ID.
     * @param id id of the event
     */
    public void setId(String id) {
        this.id = id;
    }


    /**
     * Getter method to retrieve the date and time of the event.
     * @return
     *      Return the date and time of the event as a String.
     */
    @PropertyName("dateTime")
    public String getDateTime() {
        return dateTime;
    }


    /**
     * Setter method to set the date and time of the event.
     * @param dateTime the provided date and time to the event instance
     */
    @PropertyName("dateTime")
    public void setDate(String dateTime) {
        this.dateTime = dateTime;
    }


    /**
     * Getter method to retrieve the title of the event.
     * @return
     *      Return the event's title
     */
    @PropertyName("name")
    public String getTitle() {
        return title;
    }


    /**
     * Setter method to set the title of the event.
     * @param title the provided title to the event instance.
     */
    @PropertyName("name")
    public void setTitle(String title) {
        this.title = title;
    }


    /**
     * Getter method to retrieve the description of the event.
     * @return the event's description.
     */
    public String getDescription() {
        return description;
    }


    /**
     * Setter method to set the description of the event.
     * @param description the provided description to the event instance.
     */
    public void setDescription(String description) {
        this.description = description;
    }


    /**
     * Getter method to retrieve the poster URL of the event.
     * @return the URL pointing to the event's poster image.
     */
    public String getPosterUrl() {
        return posterUrl;
    }


    /**
     * Setter method to set the poster URL of the event.
     * @param posterUrl the provided URL to the event's poster.
     */
    public void setPosterUrl(String posterUrl) {
        this.posterUrl = posterUrl;
    }

    @PropertyName("qrCodeUrl")
    public String getQRcode() {
        return QRcode;
    }

    @PropertyName("qrCodeUrl")
    public void setQRcode(String QRcode) {
        this.QRcode = QRcode;
    }

    /**
     * Getter method to retrieve the limit on the number of entrants for the event.
     * @return the maximum number of entrants allowed for the event.
     */
    public Long getLimitEntrants() {
        return limitEntrants;
    }


    /**
     * Setter method to set the limit on the number of entrants for the event.
     * @param limitEntrants the provided limit value to the event instance.
     */
    public void setLimitEntrants(Long limitEntrants) {
        this.limitEntrants = limitEntrants;
    }


    /**
     * Setter method to set if the event requires geolocation
     * @param geo true or false
     */
    @PropertyName("geolocationEnabled")
    public void setGeo(boolean geo){
        this.geolocationEnabled = geo;
    }


    /**
     * Getter method to get if the event required geolocation
     * @return true or false
     */
    @PropertyName("geolocationEnabled")
    public boolean getGeo(){
        return this.geolocationEnabled;
    }


    /**
     * Method adds an user id to the waiting list of the event
     * @param device Id of the user
     */
    public void addWaitingList(String device){
        waitingList.addUsers(device);
    }


    /**
     * Method to remove an user from the waiting list of an event
     * @param device Id of the user to remove
     */
    public void removeWaitingList(String device){
        waitingList.removeUsers(device);
    }


    /**
     * Getter method to get the waiting list of the event
     * @return Waiting list
     */
    @PropertyName("waitlist")
    public ArrayList<String> getWaitingList(){
        return this.waitingList.getList();
    }


    /**
     * Setter method to set the waiting list of the event
     * @param waitlist The waiting list to set
     */
    @PropertyName("waitlist")
    public void setWaitingList(ArrayList<String> waitlist){
        this.waitingList = new WaitingList(waitlist);
    }

    public ArrayList<String> getCancelledList() {
        return cancelledList;
    }

    public void setCancelledList(ArrayList<String> cancelledList) {
        this.cancelledList = cancelledList;
    }

    public void addToCancelledList(String user) {
        this.cancelledList.add(user);
    }

    public void removeFromCancelledList(String user) {
        this.cancelledList.remove(user);
    }

    public ArrayList<String> getConfirmedList() {
        return confirmedList;
    }

    public void setConfirmedList(ArrayList<String> confirmedList) {
        this.confirmedList = confirmedList;
    }

    public void addToConfirmedList(String user) {
        this.confirmedList.add(user);
    }

    public void removeFromConfirmedList(String user) {
        this.confirmedList.remove(user);
    }


    public ArrayList<String> getLottery(){
        return this.lottery;
    }

    public void setLottery(ArrayList lottery) {
        this.lottery = lottery;
    }

    public void removeFromLotteryList(String user) {
        this.lottery.remove(user);
    }

    public void setFinalEntrantsNum(Long num){
        this.maxCapacity = num;
    }

    public Long getFinalEntrantsNum(){
        return this.maxCapacity;
    }

    /**
     * it randomly draws user from the waiting list to the lottery list.
     */
    public void drawLottery() {
        if (waitingList == null || waitingList.getList().isEmpty()) {
            throw new IllegalStateException("The waiting list is empty or not initialized.");
        }

        if (maxCapacity > waitingList.getList().size()) {
            throw new IllegalStateException("Final entrants number exceeds the number of available users.");
        }

        Random rand = new Random();

        while (lottery.size() < maxCapacity) {
            int length = waitingList.getList().size();
            int index = rand.nextInt(length); // Generates a valid index
            String selectedUser = waitingList.getUser(index);

            lottery.add(selectedUser); // Add user to the lottery
            waitingList.removeUsers(selectedUser); // Remove user from the waiting list
        }
    }

    public boolean getFirstDraw(){
        return this.firstDraw;
    }


    public void setFirstDraw(boolean draw){
        this.firstDraw = draw;

    }





}